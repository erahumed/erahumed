#' Albufera Hydrological Balance
#'
#' Documentation TBD
#'
#' @export
hydro_balance <- function(
    outflows_df = albufera_outflows,
    weather_df = albufera_weather,
    clusters_df = albufera_clusters
    )
{
  # Can we generalize this function so that it only receives a minimal set of
  # vectors (required to do all computations)? This would be much more
  # transparent of having to input a dataframe whose structure is hard to specify.

  # level = numeric(N),
  # outflows = data.frame(N) or list() of numeric(N)s
  # P = numeric(N), ETP = numeric(N)
  # .. tancats outflow should be substituted by a column "extra_outflow" or "imbalance"

  # TODO: Check that outflows_df and weather_df have the correct format

  res <- merge(outflows_df, weather_df, by = "date", sort = TRUE)

  res$volume <- linear_storage_curve(res$level)
  res$volume_change <- c(res$volume[-1], NA) - res$volume
  res <- na.omit(res)  # Omit NAs generated by previous line

  res$petp_change <- petp_volume_change(res$P, res$ETP)

  res$total_outflow <- res$pujol + res$perellonet + res$perello
  res$total_inflow <- res$total_outflow +
    (res$volume_change - res$petp_change) / s_per_day()
  res$tancats_outflow <- ifelse(res$total_inflow < 0, -res$total_inflow / 6, 0)
  res$total_inflow[res$total_inflow < 0] <- 0


  res$residence_time_days <- residence_time(res$volume, res$total_inflow)

  res <- compute_hb_imputed_cols(res)

  # TODO: consider doing this in a more idiomatic way, e.g. using
  # reshape() - base equivalent of tidyr::pivot_wider()
  ditch_inflow_pct <- compute_ditch_inflow_pct(clusters_df)
  for (i in 1:nrow(ditch_inflow_pct)) {
    ditch <- ditch_inflow_pct$ditch[i]
    inflow_pct <- ditch_inflow_pct$inflow_pct[i]

    res[, ditch] <- inflow_pct * res$total_inflow
  }

  return(res)
}

compute_hb_imputed_cols <- function(df) {
  df$volume_is_imputed <- df$level_is_imputed
  df$data_is_imputed <-
    df$level_is_imputed |
    df$pujol_is_imputed |
    df$perellonet_is_imputed |
    df$perello_is_imputed
  df$volume_change_is_imputed <- df$volume_is_imputed
  df$petp_change_is_imputed <- FALSE
  df$total_outflow_is_imputed <-
    df$pujol_is_imputed |
    df$perellonet_is_imputed |
    df$perello_is_imputed
  df$total_inflow_is_imputed <- df$data_is_imputed
  df$tancats_outflow_is_imputed <- df$total_inflow_is_imputed
  df$residence_time_days_is_imputed <- df$data_is_imputed
  return(df)
}


#' Residence Time
#'
#' @author Pablo Amador Crespo, Valerio Gherardi
#'
#' @description
#' Computes residence times as
#' \eqn{t = s_k(\text{Volume}) / s_k(\vert \text{Inflow}\vert) },
#' where \eqn{s_k(\cdot)} denotes a moving average with a smoothing window of
#' size \eqn{k}, centered at the current observation, and
#' \eqn{\vert \cdot \vert} is the absolute value (to deal with cases in which
#' the inflow becomes negative).
#'
#' @param volume numeric vector. Time series of volumes in \eqn{\text{m}^3}.
#' @param total_inflow numeric vector. Time series of total inflow in
#' \eqn{\text{m}^3 / \text{s}}.
#' @param k positive integer. Size of the window in the moving average. The
#' default is of the order of magnitude of actual residence time for the
#' Albufera Lake.
#' @param units either \code{"days"} or \code{"seconds"}. Units of measure for
#' the returned time series.
#'
#' @return A numeric vector. Time series of residence times, in the units of
#' measure specified by the \code{units} argument (assuming \code{volume} and
#' \code{total_inflow} are provided in the correct units).
#'
#' @export
residence_time <- function(
    volume, total_inflow, k = 61, units = c("days", "seconds")
    )
{
  assert_positive_vector(volume)
  assert_positive_vector(total_inflow)
  assert_positive_integer(k)
  units <- match.arg(units)

  norm <- switch(units,
                 days = s_per_day(),
                 seconds = 1
                 )

  vol_smooth <- moving_average(volume, k)
  inflow_smooth <- moving_average(total_inflow, k)

  return(vol_smooth / inflow_smooth / norm)
}



#' Linear Storage Curve
#'
#' @author Pablo Amador Crespo, Valerio Gherardi
#'
#' @description
#' Computes the lake's volume from its level using a linear storage curve,
#' *i.e.* \eqn{\text{Volume} = \text{slope} \times \text{Level} + \text{intercept}}.
#'
#' @param level numeric vector. Levels of the lake (in meters above sea level).
#' Accepts vectorized input.
#' @param intercept a number. Intercept of the linear storage curve.
#' @param slope a number. Slope of the linear storage curve
#'
#' @return A numeric vector of the same length of `level`. Computed volumes (in
#' \eqn{\text{m}^3}).
#'
#' @details
#' The default values (for the Albufera Lake) are taken from the CHJ report
#' [Modelo de seguimiento de lâ€™Albufera de Valencia con AQUATOOLDMA.](https://www.chj.es/Descargas/ProyectosOPH/Consulta%20publica/PHC-2015-2021/ReferenciasBibliograficas/HumedalesZonasProtegidas/CHJ,2012.Aquatool_Albufera.pdf)
#'
#' @export
linear_storage_curve <- function(
    level, intercept = 16.7459 * 1e6, slope = 23.6577 * 1e6
    )
{
  assert_numeric_vector(level)
  assert_positive_number(intercept)
  assert_positive_number(slope)

  level * slope + intercept
}



#' Volume daily changes due to Precipitation and Evapotranspiration
#'
#' @author Pablo Amador Crespo, Valerio Gherardi
#'
#' @description
#' Computes the volume daily changes due to precipitation and evapotranspiration
#' as \eqn{\Delta V = \Delta h_\text{P} \cdot S_\text{P} - \Delta h_\text{ETP} \cdot S_\text{ETP}}, where
#' \eqn{\Delta h _\text{P,ETP}} are precipitation and evapotranspiration in
#' expressed in millimiters, and \eqn{S_{\text{P,ETP}}} are effective surfaces.
#'
#' @param P,ETP numeric vectors of same length. Values of precipitation and
#' evapotranspiration in \eqn{\text{mm}}.
#' @param surface_P,surface_ETP positive numbers. The effective surfaces (
#' expressed in \eqn{\text{m}^2}) for volume changes due to precipitation and
#' evapotranspiration (see description).
#'
#' @return A dataframe containing the same columns as `input`, and an additional
#' column (see `output_col` argument) with the computed values of volume
#' daily changes, expressed in \eqn{\text{m} ^3 / \text{s}}.
#'
#' @details
#' TODO: document the extraction of effective surface values.
#' TODO: other options to obtain volume changes?
#'
#' @export
petp_volume_change <- function(
    P, ETP, surface_P = 114.225826072 * 1e6, surface_ETP = 79.360993685 * 1e6
    )
{
  assert_numeric_vector(P)
  assert_numeric_vector(ETP)
  assert_positive_number(surface_P)
  assert_positive_number(surface_ETP)

  (P * surface_P - ETP * surface_ETP) / 1000
}



#' Compute Ditch Inflow Percent
#'
#' @author Pablo Amador Crespo, Valerio Gherardi
#'
#' @description Computes the fraction of water that flows through each ditch, as
#' the fraction of total surface covered by the clusters adjacent to said ditch.
#'
#' @param clusters_df A dataframe containing two columns `ditch` and `area`.
#' Each row is assumed to represent a distinct cluster pertaining to `ditch`,
#' and with the surface specified by `area`.
#'
#' @return A dataframe containing two columns, `ditch` and `inflow_pct`,
#' specifying a ditch and the amount of inflow corresponding to it,
#' respectively.
#'
#' @details
#' TODO: other options to obtain ditch percents (e.g. empirical data by Soria et al.)?
#'
#' @export
compute_ditch_inflow_pct <- function(cluster_data)
{
  res <- aggregate(area ~ ditch, data = cluster_data, FUN = sum)
  res$area <- res$area / sum(res$area)
  names(res)[names(res) == "area"] <- "inflow_pct"
  res <- res[order(res$ditch), ]
  return(res)
}
